<h2>WhyPython</h2>

<p>
    I believe that Python is important for software development. While there are more powerful languages 
    (e.g. Lisp), faster languages (e.g. C), more used languages (e.g. Java), and weirder languages (e.g. 
    Haskell), Python gets a lot of different things right, and right in a combination that no other language I 
    know of has done so far.
</p>

<p>
    It recognises that you’ll spend a lot more time reading code than writing it, and focuses on guiding 
    developers to write readable code. It’s possible to write obfuscated code in Python, but the easiest way 
    to write the code (assuming you know Python) is almost always a way that is reasonable terse, and 
    more importantly: code that clearly signals intent. If you know Python, you can work with almost any 
    Python with little effort. Even libraries that add “magic” functionality can be written in perfectly 
    readable Python (compare this to understanding the implementation of a framework such as Spring in Java).
</p>

<p>
    Python also acknowledges that speed of development is important. Readable and terse code is part of 
    this, and so is access to powerful constructs that avoid tedious repetition of code. Maintainability also 
    ties into this - LoC may be a all but useless metric, but it does say something about how much code you 
    have to scan, read and/or understand to troubleshoot problems or tweak behaviours.
</p>

<p>
    This speed of development, the ease with which a programmer of other languages can pick up basic 
    Python skills, and the huge standard library is key to another area where Python excels - toolmaking. 
    Any project of size will have tasks to automate, and automating them in Python is in my experience 
    orders of magnitude faster than using more mainstream languages - in fact, that was how I started out 
    with Python, creating a tool to automate configuring Rational Purify for a project where it before was 
    such a chore that it was never run (and memory leaks were not fixed). I’ve since created tools to extract 
    information from ticket systems and presenting them in a way useful to the team, tools to check poms 
    in a Maven project, Trac integration, custom monitoring tools... and a whole lot more. All of those tools 
    have been quick to implement, saved a lot of time, and several of them has later been patched and 
    updated by people with no Python background - without breaking.
</p>

<p>
    That building custom tools is easy hints at another strength - building and maintaining custom software 
    is easy, period. This is why, while the quite huge Django framework might be the most famous Python 
    web framework, there is also a host of successful small and micro-frameworks. When working in a 
    powerful programming language with a wide array of standard and third-party libraries, you often don’t
    need to accept the trade-offs that are necessary when using any large off-the-shelf framework. This 
    means that you can build exactly the software your customers want, rather than telling them that ”this is 
    how it’s done, sorry”. To me, this is a huge difference. I feel ashamed when I have to tell a customer 
    that no, sorry, this seems like a simple requirement, but the framework we use makes it impossible or 
    prohibitively expensive to implement. Whenever this happens, you have failed. Writing software that 
    fits into the customer’s model rather than into a framework is important, and I for one feel that a lot of 
    developers today has lost sight of that simple fact. A lot of programmers now spend more time being 
    configurators of frameworks and makíng excuses for their shortcomings, rather than actual programming.
</p>

@section CurrentPage{
    <strong>Learn -> Python -> WhyPython</strong>
}